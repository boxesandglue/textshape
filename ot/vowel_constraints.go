// Code generated by cmd/gen-vowel-constraints. DO NOT EDIT.
// Source: IndicShapingInvalidCluster.txt and Scripts.txt
//
// HarfBuzz equivalent: hb-ot-shaper-vowel-constraints.cc

package ot

// DottedCircle is the Unicode codepoint for the dotted circle character.
// It is inserted between invalid vowel sequences.
const DottedCircle Codepoint = 0x25CC

// VowelConstraint represents a prohibited vowel sequence.
// If this sequence is found, a dotted circle should be inserted.
type VowelConstraint struct {
	Codepoints []Codepoint
}

// VowelConstraints maps script names to their prohibited vowel sequences.
// HarfBuzz equivalent: _hb_preprocess_text_vowel_constraints()
var VowelConstraints = map[string][]VowelConstraint{
	"Devanagari": {
		{Codepoints: []Codepoint{0x0905, 0x0946}},
		{Codepoints: []Codepoint{0x0905, 0x093E}},
		{Codepoints: []Codepoint{0x0930, 0x094D, 0x0907}},
		{Codepoints: []Codepoint{0x0909, 0x0941}},
		{Codepoints: []Codepoint{0x090F, 0x0945}},
		{Codepoints: []Codepoint{0x090F, 0x0946}},
		{Codepoints: []Codepoint{0x090F, 0x0947}},
		{Codepoints: []Codepoint{0x0905, 0x0949}},
		{Codepoints: []Codepoint{0x0906, 0x0945}},
		{Codepoints: []Codepoint{0x0905, 0x094A}},
		{Codepoints: []Codepoint{0x0906, 0x0946}},
		{Codepoints: []Codepoint{0x0905, 0x094B}},
		{Codepoints: []Codepoint{0x0906, 0x0947}},
		{Codepoints: []Codepoint{0x0905, 0x094C}},
		{Codepoints: []Codepoint{0x0906, 0x0948}},
		{Codepoints: []Codepoint{0x0905, 0x0945}},
		{Codepoints: []Codepoint{0x0905, 0x093A}},
		{Codepoints: []Codepoint{0x0905, 0x093B}},
		{Codepoints: []Codepoint{0x0906, 0x093A}},
		{Codepoints: []Codepoint{0x0905, 0x094F}},
		{Codepoints: []Codepoint{0x0905, 0x0956}},
		{Codepoints: []Codepoint{0x0905, 0x0957}},
	},
	"Bengali": {
		{Codepoints: []Codepoint{0x0985, 0x09BE}},
		{Codepoints: []Codepoint{0x098B, 0x09C3}},
		{Codepoints: []Codepoint{0x098C, 0x09E2}},
	},
	"Gurmukhi": {
		{Codepoints: []Codepoint{0x0A05, 0x0A3E}},
		{Codepoints: []Codepoint{0x0A72, 0x0A3F}},
		{Codepoints: []Codepoint{0x0A72, 0x0A40}},
		{Codepoints: []Codepoint{0x0A73, 0x0A41}},
		{Codepoints: []Codepoint{0x0A73, 0x0A42}},
		{Codepoints: []Codepoint{0x0A72, 0x0A47}},
		{Codepoints: []Codepoint{0x0A05, 0x0A48}},
		{Codepoints: []Codepoint{0x0A73, 0x0A4B}},
		{Codepoints: []Codepoint{0x0A05, 0x0A4C}},
	},
	"Gujarati": {
		{Codepoints: []Codepoint{0x0A85, 0x0ABE}},
		{Codepoints: []Codepoint{0x0A85, 0x0AC5}},
		{Codepoints: []Codepoint{0x0A85, 0x0AC7}},
		{Codepoints: []Codepoint{0x0A85, 0x0AC8}},
		{Codepoints: []Codepoint{0x0A85, 0x0AC9}},
		{Codepoints: []Codepoint{0x0A85, 0x0ACB}},
		{Codepoints: []Codepoint{0x0A85, 0x0ABE, 0x0AC5}},
		{Codepoints: []Codepoint{0x0A85, 0x0ACC}},
		{Codepoints: []Codepoint{0x0A85, 0x0ABE, 0x0AC8}},
		{Codepoints: []Codepoint{0x0AC5, 0x0ABE}},
	},
	"Oriya": {
		{Codepoints: []Codepoint{0x0B05, 0x0B3E}},
		{Codepoints: []Codepoint{0x0B0F, 0x0B57}},
		{Codepoints: []Codepoint{0x0B13, 0x0B57}},
	},
	"Tamil": {
		{Codepoints: []Codepoint{0x0B85, 0x0BC2}},
	},
	"Telugu": {
		{Codepoints: []Codepoint{0x0C12, 0x0C55}},
		{Codepoints: []Codepoint{0x0C12, 0x0C4C}},
		{Codepoints: []Codepoint{0x0C3F, 0x0C55}},
		{Codepoints: []Codepoint{0x0C46, 0x0C55}},
		{Codepoints: []Codepoint{0x0C4A, 0x0C55}},
	},
	"Kannada": {
		{Codepoints: []Codepoint{0x0C89, 0x0CBE}},
		{Codepoints: []Codepoint{0x0C92, 0x0CCC}},
		{Codepoints: []Codepoint{0x0C8B, 0x0CBE}},
	},
	"Malayalam": {
		{Codepoints: []Codepoint{0x0D07, 0x0D57}},
		{Codepoints: []Codepoint{0x0D09, 0x0D57}},
		{Codepoints: []Codepoint{0x0D0E, 0x0D46}},
		{Codepoints: []Codepoint{0x0D12, 0x0D3E}},
		{Codepoints: []Codepoint{0x0D12, 0x0D57}},
	},
	"Sinhala": {
		{Codepoints: []Codepoint{0x0D85, 0x0DCF}},
		{Codepoints: []Codepoint{0x0D85, 0x0DD0}},
		{Codepoints: []Codepoint{0x0D85, 0x0DD1}},
		{Codepoints: []Codepoint{0x0D8B, 0x0DDF}},
		{Codepoints: []Codepoint{0x0D8D, 0x0DD8}},
		{Codepoints: []Codepoint{0x0D8F, 0x0DDF}},
		{Codepoints: []Codepoint{0x0D91, 0x0DCA}},
		{Codepoints: []Codepoint{0x0D91, 0x0DD9}},
		{Codepoints: []Codepoint{0x0D91, 0x0DDA}},
		{Codepoints: []Codepoint{0x0D91, 0x0DDC}},
		{Codepoints: []Codepoint{0x0D91, 0x0DDD}},
		{Codepoints: []Codepoint{0x0D91, 0x0DDE}},
		{Codepoints: []Codepoint{0x0D94, 0x0DDF}},
	},
	"Brahmi": {
		{Codepoints: []Codepoint{0x11005, 0x11038}},
		{Codepoints: []Codepoint{0x1100B, 0x1103E}},
		{Codepoints: []Codepoint{0x1100F, 0x11042}},
	},
	"Khojki": {
		{Codepoints: []Codepoint{0x11200, 0x1122C}},
		{Codepoints: []Codepoint{0x11240, 0x1122E}},
		{Codepoints: []Codepoint{0x11206, 0x1122C}},
		{Codepoints: []Codepoint{0x11200, 0x11231}},
		{Codepoints: []Codepoint{0x11200, 0x11233}},
		{Codepoints: []Codepoint{0x11200, 0x1122C, 0x11231}},
		{Codepoints: []Codepoint{0x1122C, 0x11230}},
		{Codepoints: []Codepoint{0x1122C, 0x11231}},
	},
	"Khudawadi": {
		{Codepoints: []Codepoint{0x112B0, 0x112E0}},
		{Codepoints: []Codepoint{0x112B0, 0x112E5}},
		{Codepoints: []Codepoint{0x112B0, 0x112E6}},
		{Codepoints: []Codepoint{0x112B0, 0x112E7}},
		{Codepoints: []Codepoint{0x112B0, 0x112E8}},
	},
	"Tirhuta": {
		{Codepoints: []Codepoint{0x11481, 0x114B0}},
		{Codepoints: []Codepoint{0x114AA, 0x114B5}},
		{Codepoints: []Codepoint{0x114AA, 0x114B6}},
		{Codepoints: []Codepoint{0x1148B, 0x114BA}},
		{Codepoints: []Codepoint{0x1148D, 0x114BA}},
	},
	"Modi": {
		{Codepoints: []Codepoint{0x11600, 0x11639}},
		{Codepoints: []Codepoint{0x11600, 0x1163A}},
		{Codepoints: []Codepoint{0x11601, 0x11639}},
		{Codepoints: []Codepoint{0x11601, 0x1163A}},
	},
	"Takri": {
		{Codepoints: []Codepoint{0x11680, 0x116AD}},
		{Codepoints: []Codepoint{0x11686, 0x116B2}},
		{Codepoints: []Codepoint{0x11680, 0x116B4}},
		{Codepoints: []Codepoint{0x11680, 0x116B5}},
	},
}

// scriptNameFromTag converts an OpenType script tag to a Unicode script name.
// OpenType script tags use mixed case (first letter uppercase), but version 2 tags are lowercase.
func scriptNameFromTag(tag Tag) string {
	switch tag {
	case MakeTag('D', 'e', 'v', 'a'), MakeTag('d', 'e', 'v', '2'):
		return "Devanagari"
	case MakeTag('B', 'e', 'n', 'g'), MakeTag('b', 'n', 'g', '2'):
		return "Bengali"
	case MakeTag('G', 'u', 'r', 'u'), MakeTag('g', 'u', 'r', '2'):
		return "Gurmukhi"
	case MakeTag('G', 'u', 'j', 'r'), MakeTag('g', 'j', 'r', '2'):
		return "Gujarati"
	case MakeTag('O', 'r', 'y', 'a'), MakeTag('o', 'r', 'y', '2'):
		return "Oriya"
	case MakeTag('T', 'a', 'm', 'l'), MakeTag('t', 'm', 'l', '2'):
		return "Tamil"
	case MakeTag('T', 'e', 'l', 'u'), MakeTag('t', 'e', 'l', '2'):
		return "Telugu"
	case MakeTag('K', 'n', 'd', 'a'), MakeTag('k', 'n', 'd', '2'):
		return "Kannada"
	case MakeTag('M', 'l', 'y', 'm'), MakeTag('m', 'l', 'm', '2'):
		return "Malayalam"
	case MakeTag('S', 'i', 'n', 'h'):
		return "Sinhala"
	case MakeTag('B', 'r', 'a', 'h'):
		return "Brahmi"
	case MakeTag('T', 'a', 'k', 'r'):
		return "Takri"
	case MakeTag('K', 'h', 'o', 'j'):
		return "Khojki"
	case MakeTag('S', 'i', 'n', 'd'):
		return "Khudawadi"
	case MakeTag('T', 'i', 'r', 'h'):
		return "Tirhuta"
	case MakeTag('M', 'o', 'd', 'i'):
		return "Modi"
	}
	return ""
}

// CheckVowelConstraints checks if a sequence starting at the given position
// matches any prohibited vowel sequence for the script.
// Returns the length of the matched constraint (0 if no match).
// HarfBuzz equivalent: pattern matching in _hb_preprocess_text_vowel_constraints()
func CheckVowelConstraints(codepoints []Codepoint, pos int, script Tag) int {
	scriptName := scriptNameFromTag(script)
	if scriptName == "" {
		return 0
	}

	constraints, ok := VowelConstraints[scriptName]
	if !ok {
		return 0
	}

	remaining := len(codepoints) - pos
	for _, c := range constraints {
		if len(c.Codepoints) > remaining {
			continue
		}

		match := true
		for i, cp := range c.Codepoints {
			if codepoints[pos+i] != cp {
				match = false
				break
			}
		}

		if match {
			return len(c.Codepoints)
		}
	}

	return 0
}

// NeedsVowelConstraintProcessing returns true if the script has vowel constraints.
func NeedsVowelConstraintProcessing(script Tag) bool {
	scriptName := scriptNameFromTag(script)
	if scriptName == "" {
		return false
	}
	_, ok := VowelConstraints[scriptName]
	return ok
}

// outputWithDottedCircle inserts a dotted circle and then copies the next glyph.
// HarfBuzz equivalent: _output_with_dotted_circle() in hb-ot-shaper-vowel-constraints.cc:30-35
func outputWithDottedCircle(buf *Buffer) {
	// Create dotted circle glyph info (inherits cluster from current glyph)
	// Note: At this stage, GlyphID is still the codepoint value (before cmap lookup)
	// We must set BOTH GlyphID and Codepoint to DottedCircle.
	info := buf.Info[buf.Idx]
	info.GlyphID = GlyphID(DottedCircle)
	info.Codepoint = DottedCircle
	buf.outputInfo(info)
	// Copy next glyph and advance
	buf.nextGlyph()
}

// PreprocessVowelConstraints inserts dotted circles between invalid vowel sequences.
// HarfBuzz equivalent: _hb_preprocess_text_vowel_constraints() in hb-ot-shaper-vowel-constraints.cc
//
// This function scans the buffer for script-specific prohibited vowel sequences
// and inserts a dotted circle (U+25CC) to break them up. This prevents text from
// looking like a different vowel than intended.
//
// Uses HarfBuzz's output buffer pattern: clear_output(), next_glyph(), output_glyph(), sync()
func PreprocessVowelConstraints(buf *Buffer) {
	if buf.Len() < 2 {
		return
	}

	// Check if script has any vowel constraints
	if !NeedsVowelConstraintProcessing(buf.Script) {
		return
	}

	// Initialize output buffer
	// HarfBuzz: buffer->clear_output() in hb-ot-shaper-vowel-constraints.cc:54
	buf.clearOutput()

	count := len(buf.Info)

	// Scan buffer and match prohibited sequences
	// HarfBuzz uses inline switch statements per script, we use a table-based approach
	for buf.Idx < count {
		// Check if current position starts a prohibited sequence
		matchLen := checkVowelConstraintAtIdx(buf, count)

		if matchLen > 0 {
			// Copy all glyphs except the last one
			for i := 0; i < matchLen-1; i++ {
				buf.nextGlyph()
			}
			// Insert dotted circle and copy last glyph
			// HarfBuzz: _output_with_dotted_circle(buffer) in hb-ot-shaper-vowel-constraints.cc:105
			outputWithDottedCircle(buf)
		} else {
			// No match, just copy the current glyph
			buf.nextGlyph()
		}
	}

	// Finalize: copy any remaining glyphs and swap buffers
	// HarfBuzz: buffer->sync() in hb-ot-shaper-vowel-constraints.cc:472
	buf.sync()
}

// checkVowelConstraintAtIdx checks if the buffer at current Idx position
// matches a prohibited vowel sequence. Returns the length of the match (0 if no match).
func checkVowelConstraintAtIdx(buf *Buffer, count int) int {
	if buf.Idx >= count {
		return 0
	}

	scriptName := scriptNameFromTag(buf.Script)
	if scriptName == "" {
		return 0
	}

	constraints, ok := VowelConstraints[scriptName]
	if !ok {
		return 0
	}

	remaining := count - buf.Idx
	for _, c := range constraints {
		if len(c.Codepoints) > remaining {
			continue
		}

		match := true
		for i, cp := range c.Codepoints {
			if buf.Info[buf.Idx+i].Codepoint != cp {
				match = false
				break
			}
		}

		if match {
			return len(c.Codepoints)
		}
	}

	return 0
}
